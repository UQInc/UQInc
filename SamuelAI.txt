t 18, 2024
You said:
Can you help me with the draw_texture for buymenu_icon, currently it is not rendering at all:
pub fn gui(textures: &HashMap<String, Texture2D>, game_state: &mut GameState, font: Option<&Font>) {
   
    let screen_height = screen_height();
    let screen_width = screen_width();
    let buy_frame_width = (screen_width * 0.7) / 2 as f32;
    // Define the dimensions and positions of the rectangles
    let rects = [
        Rect::new(screen_width - buy_frame_width, 0.0, 0.5 * buy_frame_width, 0.09 * screen_height), 
        Rect::new(screen_width - buy_frame_width + (buy_frame_width / 2.0), 0.0, 0.5 * buy_frame_width, 0.09 * screen_height),
        Rect::new(screen_width - buy_frame_width, screen_height * 0.1, buy_frame_width, screen_height * 0.16),
        Rect::new(screen_width - buy_frame_width, screen_height * 0.27, buy_frame_width, screen_height * 0.16),
        Rect::new(screen_width - buy_frame_width, screen_height * 0.44, buy_frame_width, screen_height * 0.16),
        Rect::new(screen_width - buy_frame_width, screen_height * 0.61, buy_frame_width, screen_height * 0.16),
        Rect::new(screen_width - buy_frame_width, screen_height * 0.78, buy_frame_width, screen_height * 0.16),
    ];
    //Positioning variables for currency widget
    
    // Handle click events
    if is_mouse_button_pressed(MouseButton::Left) {
        let mouse_position = mouse_position();
        
        for (index, rect) in rects.iter().enumerate() {
            if rect.contains(mouse_position.into()) {
                // Trigger the corresponding event based on index
                match index {
                    0 => { // Build Button
                        println!("CLICKED 0");
                        game_state.menu_type = "build".to_string();
                        println!("{}",game_state.menu_type);
                    },
                    1 => { // Perks Button
                        println!("CLICKED 1");
                        game_state.menu_type = "perks".to_string();
                        println!("{}",game_state.menu_type);
                    },
                    2 => {
                        println!("CLICKED 3");
                        buy_building(game_state,0);
                    },
                    3 => {
                        println!("CLICKED 4");
                        buy_building(game_state,1);
                    },
                    4 => {
                        println!("CLICKED 5");
                        buy_building(game_state,2);
                    },
                    5 => {
                        println!("CLICKED 6");
                        buy_building(game_state,3);
                    },
                    6 => {
                        println!("CLICKED 7");
                        buy_building(game_state,4);
                    },
                    _ => {}
                }
            }
        }
    }
    
    // // Default game frame
    // // viewport, x = 0, y = 0, width, height.
    // let game_frame = Camera2D {
    //     target: vec2(0.0, 0.0),
    //     zoom: vec2(1.0, 1.0),
    //     viewport: Some((0, 0, (screen_width * 0.7) as i32, screen_height as i32 * 2)),
    //     ..Default::default()
    // };

    // Frame for buying upgrades, perks, etc.
    // viewport, x = 540, y = 0, width, height.
    let buy_frame = Camera2D {
        target: vec2(0.0, 0.0),
        zoom: vec2(1.0, 1.0),
        viewport: Some((
            (screen_width * 0.7) as i32,
            0,
            (screen_width * 0.3) as i32,
            screen_height as i32 * 2,
        )),
        ..Default::default()
    };

    // let stat_frame = Camera2D {
    //     target: vec2(0.0, 0.0),
    //     zoom: vec2(1.0, 1.0),
    //     viewport: Some((
    //         (buy_frame_width - 800.0) as i32,
    //         (screen_height * 0.85) as i32,
    //         (screen_width * 0.7) as i32,
    //         (screen_height * 0.3) as i32,
    //     )),

    //     ..Default::default()
    // };

    
    //Scale the game map to fit a 1:1 aspect ratio and draw the game map
    let game_window_dimensions = ((screen_width * 0.7) as i32, screen_height as i32);

    let background_texture = textures.get("Background").unwrap();
    let foreground_texture = textures.get("Foreground").unwrap();
    let buymenu_icon = textures.get("BuyIcon").unwrap();
    let ratio = background_texture.width() / background_texture.height();

    let map_size_x = min(game_window_dimensions.0, (game_window_dimensions.1 as f32 * ratio) as i32);
    let map_size_y = map_size_x as f32 / ratio;

    let map_x_pos = max(0, (game_window_dimensions.0 - map_size_x) / 2) as f32;
    let map_y_pos = max(0, (game_window_dimensions.1 - map_size_y as i32) / 2) as f32;

    draw_texture_ex(background_texture, map_x_pos, map_y_pos, WHITE, DrawTextureParams {
        dest_size: Some(Vec2::new(map_size_x as f32, map_size_y as f32)),
        ..Default::default()
    });


    let widget_width = min(500, game_window_dimensions.0) as f32;
    let window_position_x = (game_window_dimensions.0 as f32 - widget_width) / 2.;
    let students_pos = 10.;
    let currency_pos = if widget_width / 2. < 150. {students_pos} else {widget_width / 2.};
    let currency_height = if currency_pos == 10. {34} else {10} as f32;
    let widget_height = if currency_pos == 10. {65} else {50} as f32;
    // root_ui().window(1, vec2(window_position_x, 0.), vec2(widget_width, widget_height), |ui| {
    //     ui.label(Vec2::new(10., 10.), "Total Students:");
    //     ui.label(Vec2::new(130., 10.), &(game_state.score.curr_students as i32).to_string());
    //     ui.label(Vec2::new(currency_pos, currency_height), "Currency $: ");
    //     ui.label(Vec2::new((currency_pos) + 95., currency_height - 2.), &(game_state.score.dollars as i32).to_string());
    // });
    // Iterating through owned buildings.
    for building in &game_state.owned_buildings {
        let building_name = building.name;
        // println!("{}",building_name);
        if let Some(texture) = textures.get(building_name) {
            draw_texture_ex(
                texture,
                map_x_pos,
                map_y_pos,
                WHITE,
                DrawTextureParams {
                    dest_size: Some(Vec2::new(map_size_x as f32, map_size_y as f32)),
                    ..Default::default()
                }
            );
        } else {
            println!("Texture for building '{}' not found!", building_name);
        }
    }

    draw_texture_ex(foreground_texture, map_x_pos, map_y_pos, WHITE, DrawTextureParams {
        dest_size: Some(Vec2::new(map_size_x as f32, map_size_y as f32)),
        ..Default::default()
    });

    // Icon for buy map.

    //let buy_x: f32 = 600.0;
    let buy_x: f32 = buy_frame_width * 0.1;
    let buy_y: f32 = screen_height * 2.0;

    // Draw the buy frame
    set_camera(&buy_frame);
    draw_rectangle(-1.0, 0.0, screen_width * 0.3, screen_height, BLACK);

    // Draw smaller rectangles inside the buy frame
    draw_rectangle(-1.0, 0.0, 2.0, 0.1, BLACK); // Top rectangle, holds Build | Perks | Stats
    draw_rectangle(-1.0, 0.0, 1.0, 0.09, middle_blue); 
    draw_rectangle(0.0, 0.0, 1.0, 0.09, dark_blue); 

    draw_rectangle(-1.0, 0.1, 2.0, 0.16, LIGHTGRAY);
    draw_rectangle(-1.0, 0.27, 2.0, 0.16, LIGHTGRAY);
    draw_rectangle(-1.0, 0.44, 2.0, 0.16, LIGHTGRAY);
    draw_rectangle(-1.0, 0.61, 2.0, 0.16, LIGHTGRAY);
    draw_rectangle(-1.0, 0.78, 2.0, 0.16, LIGHTGRAY);

    draw_texture(buymenu_icon, buy_x, buy_y, BLACK);

    // //Positioning variables for currency widget
    // draw_texture_ex(buymenu_icon, buy_x, buy_y, WHITE, DrawTextureParams {
    //     dest_size: Some(Vec2::new(80.0, 61.0)),
    //     ..Default::default()
    // });
    

    //If screen width has changed, move the window to new position
    root_ui().move_window(1, Vec2::new(window_position_x, 0.));

    // Reset to default camera
    set_default_camera();
    
    //Draw currency widget
    root_ui().window(1, vec2(window_position_x, 0.), vec2(widget_width, widget_height), |ui| {
        ui.label(Vec2::new(10., 10.), "Total Students:");
        ui.label(Vec2::new(130., 10.), &(game_state.score.curr_students as i32).to_string());
        ui.label(Vec2::new(currency_pos, currency_height), "Currency $: ");
        ui.label(Vec2::new((currency_pos) + 95., currency_height - 2.), &(game_state.score.dollars as i32).to_string());
    });


}
ChatGPT said:
ChatGPT

The issue with the buymenu_icon not rendering could be due to a few reasons related to the positioning or camera setup. Here are some potential reasons and solutions:
1. Camera Settings and Coordinates:

    The buy_y position is set to screen_height * 2.0, which might be outside the visible area of the camera, especially since the camera viewport is set to cover only a certain portion of the screen.
    The buy_x position is based on buy_frame_width * 0.1, which seems fine, but buy_y should likely be within the range of the camera’s viewport.

2. Ensure the Texture is Loaded Correctly:

    Ensure that buymenu_icon is correctly loaded into the textures HashMap and is not None.

3. Check Draw Order and Depth:

    Make sure that the icon isn't being drawn before the camera is set, or that it is not being drawn underneath something else that is being drawn later.

4. Possible Solutions:
Adjust the Position of the Icon

    Change buy_y to something that would position the icon within the visible area. For example:

rust

let buy_y: f32 = screen_height * 0.1;

Correct Placement Within the Camera's Viewport

    Ensure that the icon is drawn in the correct position relative to the camera’s viewport.

Example Update:

Here's how you might adjust the code:

rust

let buy_x: f32 = buy_frame_width * 0.1;
let buy_y: f32 = screen_height * 0.1; // Adjusted Y position

// Draw the buy frame
set_camera(&buy_frame);
draw_rectangle(-1.0, 0.0, screen_width * 0.3, screen_height, BLACK);

// Draw smaller rectangles inside the buy frame
draw_rectangle(-1.0, 0.0, 2.0, 0.1, BLACK); // Top rectangle, holds Build | Perks | Stats
draw_rectangle(-1.0, 0.0, 1.0, 0.09, middle_blue);
draw_rectangle(0.0, 0.0, 1.0, 0.09, dark_blue);

draw_rectangle(-1.0, 0.1, 2.0, 0.16, LIGHTGRAY);
draw_rectangle(-1.0, 0.27, 2.0, 0.16, LIGHTGRAY);
draw_rectangle(-1.0, 0.44, 2.0, 0.16, LIGHTGRAY);
draw_rectangle(-1.0, 0.61, 2.0, 0.16, LIGHTGRAY);
draw_rectangle(-1.0, 0.78, 2.0, 0.16, LIGHTGRAY);

draw_texture(buymenu_icon, buy_x, buy_y, BLACK);

// Reset to default camera
set_default_camera();

Debugging Tips:

    Print the Position: Print the buy_x and buy_y to ensure they are within the expected range.
    Draw a Placeholder: Instead of the texture, try drawing a simple rectangle at the same coordinates to confirm if it's an issue with positioning or the texture itself.

If this doesn't resolve the issue, you may need to double-check the texture's visibility and ensure that there are no other draw calls or camera setups that might be affecting the icon's rendering.
You said:
Can you replace all mentions of current_building_ with current_perk
And game_state.buildings.get with game_state.avaliable_perks.get

            if let Some(current_building_0) = game_state.buildings.get(0) {
                gui::buymenu_font(Some(&font), font_size, current_building_0.name.to_string(), 0);
                gui::buymenu_price(Some(&font), font_size, current_building_0.price, 0);
                gui::buymenu_description(Some(&font), font_size, current_building_0.description.to_string(), 0);
            }
            if let Some(current_building_1) = game_state.buildings.get(1) {
                gui::buymenu_font(Some(&font), font_size, current_building_1.name.to_string(), 1);
                gui::buymenu_price(Some(&font), font_size, current_building_1.price, 1);
                gui::buymenu_description(Some(&font), font_size, current_building_1.description.to_string(), 1);
            }

            if let Some(current_building_2) = game_state.buildings.get(2) {
                gui::buymenu_font(Some(&font), font_size, current_building_2.name.to_string(), 2);
                gui::buymenu_price(Some(&font), font_size, current_building_2.price, 2);
                gui::buymenu_description(Some(&font), font_size, current_building_2.description.to_string(), 2);
            }

            if let Some(current_building_3) = game_state.buildings.get(3) {
                gui::buymenu_font(Some(&font), font_size, current_building_3.name.to_string(), 3);
                gui::buymenu_price(Some(&font), font_size, current_building_3.price, 3);
                gui::buymenu_description(Some(&font), font_size, current_building_3.description.to_string(), 3);
            }

            if let Some(current_building_4) = game_state.buildings.get(4) {
                gui::buymenu_font(Some(&font), font_size, current_building_4.name.to_string(), 4);
                gui::buymenu_price(Some(&font), font_size, current_building_4.price, 4);
                gui::buymenu_description(Some(&font), font_size, current_building_4.description.to_string(), 4);
            }
ChatGPT said:
ChatGPT

Here’s the updated code with all mentions of current_building_ replaced with current_perk_ and game_state.buildings.get replaced with game_state.avaliable_perks.get:

rust

if let Some(current_perk_0) = game_state.avaliable_perks.get(0) {
    gui::buymenu_font(Some(&font), font_size, current_perk_0.name.to_string(), 0);
    gui::buymenu_price(Some(&font), font_size, current_perk_0.price, 0);
    gui::buymenu_description(Some(&font), font_size, current_perk_0.description.to_string(), 0);
}

if let Some(current_perk_1) = game_state.avaliable_perks.get(1) {
    gui::buymenu_font(Some(&font), font_size, current_perk_1.name.to_string(), 1);
    gui::buymenu_price(Some(&font), font_size, current_perk_1.price, 1);
    gui::buymenu_description(Some(&font), font_size, current_perk_1.description.to_string(), 1);
}

if let Some(current_perk_2) = game_state.avaliable_perks.get(2) {
    gui::buymenu_font(Some(&font), font_size, current_perk_2.name.to_string(), 2);
    gui::buymenu_price(Some(&font), font_size, current_perk_2.price, 2);
    gui::buymenu_description(Some(&font), font_size, current_perk_2.description.to_string(), 2);
}

if let Some(current_perk_3) = game_state.avaliable_perks.get(3) {
    gui::buymenu_font(Some(&font), font_size, current_perk_3.name.to_string(), 3);
    gui::buymenu_price(Some(&font), font_size, current_perk_3.price, 3);
    gui::buymenu_description(Some(&font), font_size, current_perk_3.description.to_string(), 3);
}

if let Some(current_perk_4) = game_state.avaliable_perks.get(4) {
    gui::buymenu_font(Some(&font), font_size, current_perk_4.name.to_string(), 4);
    gui::buymenu_price(Some(&font), font_size, current_perk_4.price, 4);
    gui::buymenu_description(Some(&font), font_size, current_perk_4.description.to_string(), 4);
}

This code snippet now refers to current_perk_ instead of current_building_ and retrieves the available perks from game_state.avaliable_perks.
Get started with ChatGPT
|
Terms of use
|
Privacy policy
|

I am making a game in Macroquad Rust, I need to add custom fonts to my text but haven't been able to work it out. Here is my code:
use macroquad::prelude::*;
use macroquad::ui::widgets::Window;
use macroquad::ui::{
    hash, root_ui,
    widgets::{self, Group},
    Drag, Ui,
};
use std::cmp::{max, min};
use std::collections::HashMap;
use std::default;
use std::thread::sleep;
use std::result::Result;

use crate::GameState;

// Score implementations
pub fn score() {}

pub struct Notification {
    text: String,
    timer: f32, // How long the notification should be displayed
}

pub struct NotificationManager {
    notifications: Vec<Notification>,
}

impl NotificationManager {
    pub fn new() -> Self {
        Self {
            notifications: Vec::new(),
        }
    }

    pub fn add_notification(&mut self, text: String, duration: f32) {
        self.notifications.push(Notification {
            text,
            timer: duration,
        });
    }

    pub fn update(&mut self, delta_time: f32) {
        // Update timers and remove expired notifications
        self.notifications.retain_mut(|notification| {
            notification.timer -= delta_time;
            notification.timer > 0.0
        });
    }

    pub fn draw(&self) {}
}

pub fn build_textdraw() {
    let text = "Build";
    let font_size = 40.0;
    let text_dimensions = measure_text(text, None, font_size as u16, 1.0);
    let x_pos = (screen_width() * 0.1);
    let y_pos = (screen_height() * 0.535);
    //let y_pos = (screen_height() * 0.63) + (text_dimensions.height / 2.0);
    draw_text_ex(
        text,
        x_pos,
        y_pos,
        TextParams {
            font_size: font_size as u16,
            font_scale: 0.7,        // Slight horizontal scale to make the text wider
            font_scale_aspect: 3.0, // Match the font scale to maintain proportions
            color: BLACK,
            ..Default::default()
        },
    );
}

pub fn perks_textdraw() {
    let text = "Perks";
    let font_size = 40.0;
    let text_dimensions = measure_text(text, None, font_size as u16, 1.0);
    let x_pos = (screen_width() * 0.45);
    let y_pos = (screen_height() * 0.535);
    //let y_pos = (screen_height() * 0.63) + (text_dimensions.height / 2.0);
    draw_text_ex(
        text,
        x_pos,
        y_pos,
        TextParams {
            font_size: font_size as u16,
            font_scale: 0.7,        // Slight horizontal scale to make the text wider
            font_scale_aspect: 3.0, // Match the font scale to maintain proportions
            color: BLACK,
            ..Default::default()
        },
    );
}

pub fn stars_textdraw() {
    let text = "Stars";
    let font_size = 40.0;
    let text_dimensions = measure_text(text, None, font_size as u16, 1.0);
    let x_pos = (screen_width() * 0.8);
    let y_pos = (screen_height() * 0.535);
    //let y_pos = (screen_height() * 0.63) + (text_dimensions.height / 2.0);
    draw_text_ex(
        text,
        x_pos,
        y_pos,
        TextParams {
            font_size: font_size as u16,
            font_scale: 0.7,        // Slight horizontal scale to make the text wider
            font_scale_aspect: 3.0, // Match the font scale to maintain proportions
            font: Some(load_ttf_font_from_bytes()),
            color: BLACK,
            ..Default::default()
        },
    );
}


pub fn gui(notification_manager: &mut NotificationManager, textures: &HashMap<String, Texture2D>, game_state: &GameState) {
     
    let screen_height = screen_height();
    let screen_width = screen_width();
    let buy_frame_width = (screen_width * 0.7) / 2 as f32;
    // Define the dimensions and positions of the rectangles
    let rects = [
        Rect::new(screen_width - buy_frame_width, 0.0, 0.33 * buy_frame_width, 0.09 * screen_height),  // Stats
        Rect::new(screen_width - buy_frame_width + (buy_frame_width / 3.0 * 1.0), 0.0, 0.33 * buy_frame_width, 0.09 * screen_height), // Build
        Rect::new(screen_width - buy_frame_width + (buy_frame_width / 3.0 * 2.0), 0.0, 0.33 * buy_frame_width, 0.09 * screen_height), // Perks
        Rect::new(screen_width - buy_frame_width, screen_height * 0.18, buy_frame_width, screen_height * 0.16),  // Other red rectangles
        Rect::new(screen_width - buy_frame_width, screen_height * 0.36, buy_frame_width, screen_height * 0.16),
        Rect::new(screen_width - buy_frame_width, screen_height * 0.54, buy_frame_width, screen_height * 0.16),
        Rect::new(screen_width - buy_frame_width, screen_height * 0.72, buy_frame_width, screen_height * 0.16),
        Rect::new(screen_width - buy_frame_width, screen_height * 0.9, buy_frame_width, screen_height * 0.16),
    ];

    // Handle click events
    if is_mouse_button_pressed(MouseButton::Left) {
        let mouse_position = mouse_position();
        
        for (index, rect) in rects.iter().enumerate() {
            if rect.contains(mouse_position.into()) {
                // Trigger the corresponding event based on index
                match index {
                    0 => {
                        println!("CLICKED 0");
                    },
                    1 => {
                        println!("CLICKED 1");
                    },
                    2 => {
                        println!("CLICKED 2");
                    },
                    3 => {
                        println!("CLICKED 3");
                    },
                    4 => {
                        println!("CLICKED 4");
                    },
                    5 => {
                        println!("CLICKED 5");
                    },
                    6 => {
                        println!("CLICKED 6");
                    },
                    7 => {
                        println!("CLICKED 7");
                    },
                    _ => {}
                }
            }
        }
    }
    // // Default game frame
    // // viewport, x = 0, y = 0, width, height.
    // let game_frame = Camera2D {
    //     target: vec2(0.0, 0.0),
    //     zoom: vec2(1.0, 1.0),
    //     viewport: Some((0, 0, (screen_width * 0.7) as i32, screen_height as i32 * 2)),
    //     ..Default::default()
    // };

    // Frame for buying upgrades, perks, etc.
    // viewport, x = 540, y = 0, width, height.
    let buy_frame = Camera2D {
        target: vec2(0.0, 0.0),
        zoom: vec2(1.0, 1.0),
        viewport: Some((
            (screen_width * 0.7) as i32,
            0,
            (screen_width * 0.3) as i32,
            screen_height as i32 * 2,
        )),
        ..Default::default()
    };

    // let stat_frame = Camera2D {
    //     target: vec2(0.0, 0.0),
    //     zoom: vec2(1.0, 1.0),
    //     viewport: Some((
    //         (buy_frame_width - 800.0) as i32,
    //         (screen_height * 0.85) as i32,
    //         (screen_width * 0.7) as i32,
    //         (screen_height * 0.3) as i32,
    //     )),

    //     ..Default::default()
    // };

    //Scale the game map to fit a 1:1 aspect ratio and draw the game map
    let game_window_dimensions = ((screen_width * 0.7) as i32, screen_height as i32);

    let map_size = min(game_window_dimensions.0, game_window_dimensions.1);

    let map_x_pos = max(0, (game_window_dimensions.0 - map_size) / 2) as f32;
    let map_y_pos = max(0, (game_window_dimensions.1 - map_size) / 2) as f32;

    draw_texture_ex(textures.get("Test1").unwrap(), map_x_pos, map_y_pos, WHITE, DrawTextureParams {
        dest_size: Some(Vec2::new(map_size as f32, map_size as f32)),
        ..Default::default()
    });

    // Draw the buy frame
    set_camera(&buy_frame);
    draw_rectangle(-1.0, 0.0, screen_width * 0.3, screen_height, LIGHTGRAY);

    // Draw smaller rectangles inside the buy frame
    draw_rectangle(-1.0, 0.0, 2.0, 0.1, BLACK); // Top rectangle, holds Build | Perks | Stats
    draw_rectangle(-1.0, 0.0, 0.66, 0.09, BLUE); // Stats
    draw_rectangle(-0.33, 0.0, 0.66, 0.09, GREEN); // Build
    draw_rectangle(0.34, 0.0, 0.66, 0.09, ORANGE); // Perks

    draw_rectangle(-1.0, 0.18, 2.0, 0.16, RED);
    draw_rectangle(-1.0, 0.36, 2.0, 0.16, RED);
    draw_rectangle(-1.0, 0.54, 2.0, 0.16, RED);
    draw_rectangle(-1.0, 0.72, 2.0, 0.16, RED);
    draw_rectangle(-1.0, 0.9, 2.0, 0.16, RED);
  
    //Positioning variables for currency widget
    let widget_width = min(500, game_window_dimensions.0) as f32;
    let window_position_x = (game_window_dimensions.0 as f32 - widget_width) / 2.;
    let students_pos = 10.;
    let currency_pos = if widget_width / 2. < 150. {students_pos} else {widget_width / 2.};
    let currency_height = if currency_pos == 10. {34} else {10} as f32;
    let widget_height = if currency_pos == 10. {65} else {50} as f32;

    println!("{}", currency_pos);

    //Draw currency widget
    root_ui().window(1, vec2(window_position_x, 0.), vec2(widget_width, widget_height), |ui| {
        ui.label(Vec2::new(10., 10.), "Total Students:");
        ui.label(Vec2::new(130., 10.), &game_state.score.curr_students.to_string());
        ui.label(Vec2::new(currency_pos, currency_height), "Currency $: ");
        ui.label(Vec2::new((currency_pos) + 95., currency_height - 2.), &game_state.score.dollars.to_string());
    });

    //If screen width has changed, move the window to new position
    root_ui().move_window(1, Vec2::new(window_position_x, 0.));

    // Reset to default camera
    set_default_camera();
    build_textdraw();
    perks_textdraw();
    stars_textdraw();

    notification_manager.update(get_frame_time());
    notification_manager.draw();
}
ChatGPT said:
ChatGPT

To add custom fonts to your text in Macroquad, you need to load the font from a file and use it in your TextParams. Here's a step-by-step guide on how to do that:

    Load the Font: First, you need to load the font from a .ttf file using load_ttf_font. This should be done asynchronously in your main function or an initialization function.

    Use the Loaded Font: Once the font is loaded, you can pass it to the font field of TextParams when drawing text.

Here’s how you can modify your code to include a custom font:
Step 1: Load the Font

Assume you have a font file named my_font.ttf in your assets folder.

rust

use macroquad::text::{Font, load_ttf_font};

async fn load_fonts() -> Font {
    load_ttf_font("assets/my_font.ttf").await.unwrap()
}

Step 2: Use the Loaded Font

Modify your gui function to load the font and use it when drawing text. You would typically load the font once and then pass it around as needed.

Here’s an example modification of your gui function:

rust

pub async fn gui(
    notification_manager: &mut NotificationManager, 
    textures: &HashMap<String, Texture2D>, 
    game_state: &GameState
) {
    let custom_font = load_fonts().await;

    // Other parts of your `gui` function remain the same...

    // Example of using the custom font in text drawing
    draw_text_ex(
        "Build",
        x_pos,
        y_pos,
        TextParams {
            font_size: 40,
            font_scale: 0.7,
            font_scale_aspect: 3.0,
            font: custom_font,
            color: BLACK,
            ..Default::default()
        },
    );

    draw_text_ex(
        "Perks",
        x_pos,
        y_pos,
        TextParams {
            font_size: 40,
            font_scale: 0.7,
            font_scale_aspect: 3.0,
            font: custom_font,
            color: BLACK,
            ..Default::default()
        },
    );

    draw_text_ex(
        "Stars",
        x_pos,
        y_pos,
        TextParams {
            font_size: 40,
            font_scale: 0.7,
            font_scale_aspect: 3.0,
            font: custom_font,
            color: BLACK,
            ..Default::default()
        },
    );

    // The rest of your `gui` function...
}

Step 3: Update build_textdraw, perks_textdraw, and stars_textdraw Functions

You will need to pass the custom font to these functions if they are being called outside of the gui function:

rust

pub fn build_textdraw(custom_font: Font) {
    draw_text_ex(
        "Build",
        x_pos,
        y_pos,
        TextParams {
            font_size: 40,
            font_scale: 0.7,
            font_scale_aspect: 3.0,
            font: custom_font,
            color: BLACK,
            ..Default::default()
        },
    );
}

pub fn perks_textdraw(custom_font: Font) {
    draw_text_ex(
        "Perks",
        x_pos,
        y_pos,
        TextParams {
            font_size: 40,
            font_scale: 0.7,
            font_scale_aspect: 3.0,
            font: custom_font,
            color: BLACK,
            ..Default::default()
        },
    );
}

pub fn stars_textdraw(custom_font: Font) {
    draw_text_ex(
        "Stars",
        x_pos,
        y_pos,
        TextParams {
            font_size: 40,
            font_scale: 0.7,
            font_scale_aspect: 3.0,
            font: custom_font,
            color: BLACK,
            ..Default::default()
        },
    );
}

Step 4: Pass the Font to the Drawing Functions

Finally, ensure that when you call these functions, you pass the custom font:

rust

build_textdraw(custom_font);
perks_textdraw(custom_font);
stars_textdraw(custom_font);

This should allow you to use your custom font in the game. Remember to handle any potential errors when loading the font, such as by using .expect() or .unwrap(), or by adding error handling logic as necessary.
Get started with ChatGPT
|
Terms of use
|
Privacy policy
|


Return Font from Bytes
August 18, 2024
You said:
How can I get this Rust function, using the Macroquad Font library to return only the FONT struct:

pub fn load_ttf_font_from_bytes() -> Font{
    let font = macroquad::text::load_ttf_font_from_bytes(include_bytes!("media/font/NewAmsterdam-Regular.ttf"));

    font
}
ChatGPT said:
ChatGPT

To return only the Font struct in the Rust function using the Macroquad Font library, you need to make sure that the function signature and the function body correctly handle the return type. The function you provided is almost correct, but you need to ensure that the Font is being returned properly, which should be done by unwrapping the Result returned by the load_ttf_font_from_bytes function.

Here’s the corrected version:

rust

pub fn load_ttf_font_from_bytes() -> Font {
    let font = macroquad::text::load_ttf_font_from_bytes(include_bytes!("media/font/NewAmsterdam-Regular.ttf")).unwrap();

    font
}

Explanation:

    unwrap(): The load_ttf_font_from_bytes function returns a Result<Font, String>. The unwrap() function is used to extract the Font from the Result if the loading is successful. If the font fails to load, unwrap() will cause the program to panic with the error message.
    Function Return Type: The function returns the Font struct directly as specified in the return type.

Considerations:

    Error Handling: Using unwrap() will cause a panic if the font fails to load. If you want to handle errors more gracefully, consider using match or expect() to provide a more informative error message or handle the error in some way.

Here’s an example with error handling:

rust

pub fn load_ttf_font_from_bytes() -> Result<Font, String> {
    let font = macroquad::text::load_ttf_font_from_bytes(include_bytes!("media/font/NewAmsterdam-Regular.ttf"))?;

    Ok(font)
}

In this version, the function now returns a Result<Font, String>, which is more idiomatic in Rust when dealing with potential failures. The caller of this function will need to handle the Result.
You said:
There is an issue with the directory, where the gui.rs file where this is being run from is in the ./src folder but the font is in the ./media/font folder however I am gettign a directory error when using media/ 
ChatGPT said:
ChatGPT

The issue you're encountering is likely related to the way the path is being resolved relative to the binary's execution directory, rather than the source code location. In Rust, when you use include_bytes!, it embeds the file directly into the binary, but the path you provide needs to be relative to the file where the macro is used.

Since your gui.rs file is located in the ./src folder and your font file is in the ./media/font folder, you can adjust the path in the include_bytes! macro to navigate out of the src folder and into the media/font folder.

Here's how you can adjust the code:

rust

pub fn load_ttf_font_from_bytes() -> Font {
    let font = macroquad::text::load_ttf_font_from_bytes(include_bytes!("../media/font/NewAmsterdam-Regular.ttf")).unwrap();

    font
}

Explanation:

    Path Adjustment: By using ../, you move up one directory level from ./src to the root of your project directory, and then you can navigate to the media/font folder.
    include_bytes! Macro: This macro works at compile-time, so it requires a valid relative path from the file where it's used.

If the font is still not found, make sure that the media folder is correctly placed at the root level of your project (i.e., alongside the src folder).
Additional Tip:

If you ever need to dynamically load the font at runtime (as opposed to embedding it into the binary), you could use the load_ttf_font function with a relative or absolute path, depending on how you want to set up your directory structure. However, using include_bytes! is generally more convenient for embedding assets in Rust applications.
You said:
It appears to still be appending src
error: couldn't read src/../media/font/NewAmsterdam-Regular.ttf: No such file or directory (os error 2)
   --> src/gui.rs:268:58
    |
268 |     let font = macroquad::text::load_ttf_font_from_bytes(include_bytes!("../media/font/NewAmsterdam-Regular.ttf")).unwrap();
    |                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this error originates in the macro include_bytes (in Nightly builds, run with -Z macro-backtrace for more info)
ChatGPT said:
ChatGPT

The issue is that include_bytes! expects the path to be relative to the location of the source file where the macro is invoked. Since it's still appending src/ to the path, it means that the relative path provided in include_bytes! isn't correctly resolving due to the way the project is structured.

To address this issue, you can try one of the following approaches:
1. Adjust the Path Relative to the Project Root

If include_bytes! is not resolving the path correctly, you can make sure the path is relative to the project root by using a full relative path that starts from the project root:

rust

pub fn load_ttf_font_from_bytes() -> Font {
    let font = macroquad::text::load_ttf_font_from_bytes(include_bytes!("../../media/font/NewAmsterdam-Regular.ttf")).unwrap();

    font
}

2. Use CARGO_MANIFEST_DIR Environment Variable

Another approach is to use the CARGO_MANIFEST_DIR environment variable, which points to the root of the crate (the directory where Cargo.toml is located). You can concatenate this with the relative path:

rust

pub fn load_ttf_font_from_bytes() -> Font {
    let font = macroquad::text::load_ttf_font_from_bytes(include_bytes!(concat!(env!("CARGO_MANIFEST_DIR"), "/media/font/NewAmsterdam-Regular.ttf"))).unwrap();

    font
}

Explanation:

    CARGO_MANIFEST_DIR: This is an environment variable provided by Cargo that points to the directory containing your Cargo.toml file (the root of your project).
    concat!: This macro is used to concatenate the CARGO_MANIFEST_DIR with the path to your font file.

3. Ensure the File is in the Correct Directory

Make sure that the media/font/NewAmsterdam-Regular.ttf file is indeed in the correct directory. The directory structure should look something like this:

css

your_project/
├── Cargo.toml
├── src/
│   └── gui.rs
└── media/
    └── font/
        └── NewAmsterdam-Regular.ttf

If the file structure is correct and you're still encountering the issue, using the CARGO_MANIFEST_DIR approach should resolve the path correctly, regardless of the current working directory.
You said:
Can you help me modify this example code so that there is a load function that only returns an Option<font> value:

/// Load font from file with "path"
pub async fn load_ttf_font(path: &str) -> Result<Font, Error> {
    let bytes = crate::file::load_file(path)
        .await
        .map_err(|_| Error::FontError("The Font file couldn't be loaded"))?;

    load_ttf_font_from_bytes(&bytes[..])
}

/// Load font from bytes array, may be use in combination with include_bytes!
/// 

ignore
/// let font = load_ttf_font_from_bytes(include_bytes!("font.ttf"));
///


pub fn load_ttf_font_from_bytes(bytes: &[u8]) -> Result<Font, Error> {
    let atlas = Arc::new(Mutex::new(Atlas::new(
        get_quad_context(),
        miniquad::FilterMode::Linear,
    )));

    let font = Font::load_from_bytes(atlas.clone(), bytes)?;

    font.populate_font_cache(&Font::ascii_character_list(), 15);

    Ok(font)
}
ChatGPT said:
ChatGPT

Certainly! To modify the example code so that there is a load function that returns an Option<Font> value, you can follow these steps:

    Create a load function that takes the path as input.
    This function will use the existing load_ttf_font function but convert the Result<Font, Error> to an Option<Font>.
    The Option<Font> will be Some(Font) if the font is successfully loaded, or None if there is an error.

Here’s how you can implement it:

rust

/// Load font from file with "path"
pub async fn load_ttf_font(path: &str) -> Result<Font, Error> {
    let bytes = crate::file::load_file(path)
        .await
        .map_err(|_| Error::FontError("The Font file couldn't be loaded"))?;

    load_ttf_font_from_bytes(&bytes[..])
}

/// Load font from bytes array, may be used in combination with include_bytes!
/// ```ignore
/// let font = load_ttf_font_from_bytes(include_bytes!("font.ttf"));
/// ```
pub fn load_ttf_font_from_bytes(bytes: &[u8]) -> Result<Font, Error> {
    let atlas = Arc::new(Mutex::new(Atlas::new(
        get_quad_context(),
        miniquad::FilterMode::Linear,
    )));

    let font = Font::load_from_bytes(atlas.clone(), bytes)?;

    font.populate_font_cache(&Font::ascii_character_list(), 15);

    Ok(font)
}

/// Load font and return an Option<Font>
/// Returns Some(Font) if successful, or None if there was an error
pub async fn load_font(path: &str) -> Option<Font> {
    match load_ttf_font(path).await {
        Ok(font) => Some(font),
        Err(_) => None,
    }
}

Explanation:

    load_font Function:
        This function is created to load the font and return an Option<Font>.
        It uses the load_ttf_font function to attempt to load the font.
        If load_ttf_font returns Ok(font), the load_font function returns Some(font).
        If there’s an error (i.e., Err(_)), it returns None.

    Result to Option Conversion:
        The conversion from Result<Font, Error> to Option<Font> is done using a match statement, where the Ok variant of the Result is mapped to Some, and the Err variant is mapped to None.

This setup provides a clean interface for loading a font and handling the case where the font file might not be found or another error occurs, without requiring error handling to propagate through the rest of your code.
You said:
I need the function is be synchronous
ChatGPT said:
ChatGPT

Certainly! If you need the load_font function to be synchronous instead of asynchronous, you can remove the async keyword and make the necessary changes. Here's how you can modify the function:

rust

/// Load font from file with "path"
pub fn load_ttf_font(path: &str) -> Result<Font, Error> {
    let bytes = crate::file::load_file_sync(path)
        .map_err(|_| Error::FontError("The Font file couldn't be loaded"))?;

    load_ttf_font_from_bytes(&bytes[..])
}

/// Load font from bytes array, may be used in combination with include_bytes!
/// ```ignore
/// let font = load_ttf_font_from_bytes(include_bytes!("font.ttf"));
/// ```
pub fn load_ttf_font_from_bytes(bytes: &[u8]) -> Result<Font, Error> {
    let atlas = Arc::new(Mutex::new(Atlas::new(
        get_quad_context(),
        miniquad::FilterMode::Linear,
    )));

    let font = Font::load_from_bytes(atlas.clone(), bytes)?;

    font.populate_font_cache(&Font::ascii_character_list(), 15);

    Ok(font)
}

/// Synchronously load font and return an Option<Font>
/// Returns Some(Font) if successful, or None if there was an error
pub fn load_font(path: &str) -> Option<Font> {
    match load_ttf_font(path) {
        Ok(font) => Some(font),
        Err(_) => None,
    }
}

Explanation:

    load_ttf_font Function:
        This function is now synchronous, and the load_file_sync function is used to load the file. You'll need to implement or use a synchronous file loading function like load_file_sync.

    Synchronous File Loading:
        The example assumes you have a synchronous file loading function like crate::file::load_file_sync. If you don't have this function, you'll need to implement a synchronous method to load the font file as bytes.

    load_font Function:
        This function is synchronous and directly calls load_ttf_font, returning Some(Font) if successful or None in case of an error.

Example of a Synchronous File Loading Function:

If you don't have load_file_sync, you can use standard Rust's file I/O utilities to implement it:

rust

use std::fs::File;
use std::io::Read;

pub fn load_file_sync(path: &str) -> Result<Vec<u8>, std::io::Error> {
    let mut file = File::open(path)?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)?;
    Ok(buffer)
}

This load_file_sync function synchronously reads the entire content of the file into a Vec<u8>, which you can then pass to the load_ttf_font_from_bytes function.
Get started with ChatGPT
|
Terms of use
|
Privacy policy
|

